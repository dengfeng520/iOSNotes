<h1><center>Runtime Notes</center></h1>

<h6 align='right'>小时光</h6>
--

> <h3>1、C语言指针</h3>


#####（1.1）、什么是指针


一般的，在定义数据对象时，需要说明对象的名称和数据类型，如


```
int test = 0;
```

申明数据类型的作用时告诉IDE要为多想分配多大的存储空间（字节），以及对象中要存储什么类型的值。

对象名称的作用是对应分配到的内存单元，允许按照名称来访问，如我定义`test`这个变量，在程序中需要使用时，就可以通过`tes`来访问这个变量。但是在一些特殊情况下如由于作用域问题无法直接访问这个变量，那么可以通过访问这个变量的内存地址来访问这个变量。

因此C语言中形象的将变量的内存地址称为**指针**，即一个对象的地址就是该对象的指针。

举个例子：我申请的int类型的`test`的指针为40001，但并不表示地址40001指的是`test`.

此处需要注意，**40001只是这个变量的首地址**，我申请的int类型的`test`在内存中占四个字节，所以40001，40002，40003，40004这四个内存地址才是`test`的内存。

所以我们常说的，**变量(对象)的指针实际上是这个变量(对象)在内存中的首地址**。

使用指针有哪些好处呢？

* 提高存储效率
* 间接访问由于作用域不可见的变量
* 访问动态的内存空间

#####（1.2）、指针和指针变量的区别

指针是地址值，指针变量是存储指针的变量，我们可以通过指针变量间接访问（或者存取）一个对象。

#####（1.3）、指针的分类

* 普通的指针

```

```
int a = 111;
int *pa = &a;
char p = 'C';
char *pb = &p;
```
```

![指针](/Users/mac001/Desktop/Study学习资料/iOSNotes/RuntimeImage/C_Pointer.png)

上图演示了指针和变量在内存中的关系，111是int型，`C`是char型。`pa`是111的指针，指向111在内存中的首地址。同理pb也指向了`C`的首地址。

分别打印一下可以看到结果：

```
printf("a====%d,&a======%p,pa====%p\n",a,&a,pa);
printf("\np======%c,&p======%p,pb====%p\n\n",p,&p,pb);
```

```
a====111,&a======0x7ffeefbff52c,pa====0x7ffeefbff52c

p======C,&p======0x7ffeefbff51f,pb====0x7ffeefbff51f
```


实际上，在内存中一个类型表示的是这变量在内存中所占的大小，因为int类型在内存中占用了4个字节的内存大小,`C`占用了一个字节的空间。

此时已经知道变量是类型、内存中的指针首地址以及该变量所占内存大小，就可以从首地址取四个字节的长度就代表着这个变量在内存中的值。

同理的`pb`的首地址再取一个字节的长度就是这个char类型`C`的内容。

* 指针的指针

![指针](/Users/mac001/Desktop/Study学习资料/iOSNotes/RuntimeImage/C_Point_Point.png)

如上图所示：`ppa`指向的存放`&a`的首地址，`ppb`指向存放`&b`的首地址。

既然普通的类型需要占用内存空间，那么指针也是需要占用内存空间的。
我们通过指针的指针拿到这个指针，再通过这个指针拿到这个指针所指向的内容。


* 数组指针

![数组的指针](/Users/mac001/Desktop/Study学习资料/iOSNotes/RuntimeImage/C_Pointer_Array.png)

如上图所示，数组的指针并不是这个数组的指针，而是数组第一个元素的首地址指针。在获取数组元素的时候可以通过第一个元素的首地址+元素在内存中的字节长度，从而获取到第二个元素的内存地址，同理可以得到不同元素的指针。

* 函数指针


![函数的指针](/Users/mac001/Desktop/Study学习资料/iOSNotes/RuntimeImage/function_Pointer.png)
函数的指针和函数非常类似，在函数前面加上一个指针括号，我们拿到函数的指针之后，就可以调用这个指针来执行函数。



> <h3>2、Runtime消息发送机制</h3>

#####（1.1）、类方法和实例方法的区别

* 类对象只可以调用类方法
* 实例对象只可以调用实例方法
* 实例方法里的self,是对象的首地址

#####（1.2）、objc_msgSend方法


#####（1.3）、消息发送流程


#####（1.4）、直接跳过消息发送流程

#####（1.5）、消息转发流程

#####（1.6）、类方法动态消息解析

#####（1.7）、实例方法动态解析

#####（1.8）、重定向

#####（1.9）、转发

#####（1.10）、模拟多继承


> <h3>3、Runtime之常用API</h3>

#####（2.1）、获取某个类objc_getClass

#####（2.2）、获取某个类的类名

#####（2.3）、获取成员变量class_copy
