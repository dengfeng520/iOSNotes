<h2><center>网络请求封装</center></h2>


本文主要处理2个问题：

* 请求Loading扩展处理
* 封装URLSession返回Observable序列

> <h3>请求Loading扩展处理</h3>

关于Loading组件，我已经封装好，并发布在Github上，[RPToastView](https://github.com/dengfeng520/RPToastView)，使用方法可参考**README.md**。
此处只需对UIViewController做一个extension，用一个属性来控制Loading组件的显示和隐藏即可，核心代码如下:

```
extension Reactive where Base: UIViewController {
    public var isAnimating: Binder<Bool> {
        return Binder(self.base, binding: { (vc, active) in
            if active == true {
                // 显示Loading View
            } else {
                // 隐藏Loading View
            }
        })
    }
}
```

此处给**isAnimating**传入**true**表示显示**LoadingView**,传入**false**表示隐藏**LoadingView**，


> <h3>为什么不使用Moya</h3>

[Github Moya](https://github.com/Moya/Moya)

**Moya**是在常用的**Alamofire**的基础上又封装了一层，但是我在工程中并没有使用**Moya**,主要是基于以下3点考虑：

* （1）、**Moya**自身原因：**Moya**封装的很完美，这虽然为开发者带来了很大的方便，但是过多封装的必然会导致可扩展性下降
* （2）、内部原因：由于我公司的后台接口没有一个统一的标准，所以不同模块后台返回的数据结构不同，所以我不得不分开处理
* （3）、基于App包大小考虑：导入过多的第三方开源库必然会使App包也同步变大，这并不是我所期望的

所以我最终的选择是**RxSwift+URLSession+SwiftyJSON**。

> <h3>RxSwift解决大量嵌套回调问题</h3>

关于网络请求，OC中常用的开源库是[AFNetworking](https://github.com/AFNetworking/AFNetworking),在Swift中我们常用[Alamofire](https://github.com/Alamofire/Alamofire)。截止2020年12月**AFNetworking**的star数量是**33.1K**,**Alamofire**的star数量是**35K**。从这个数据来说，Swift虽然是一门新的语言，但更受开发者青睐。

网络请求最简单的方法个人觉得用 **Alamofire**通过**Closures**返回是否成功或失败:

```
func post(with body: [String : AnyObject], _ path: String, with closures: @escaping ((_ json: [String : AnyObject],_ failure : String?) -> Void))
```

如果我们在用户登录成功后需要再调一次接口查询该用户**Socket**服务器相关数据，那么请求的代码就会**Closures**里嵌套**Closures**，

```
 RPAuthRemoteAPI().signIn(with: ["username":"","password":""], signInAPI) { (siginInfo, errorMsg) in
            if let errorMsg = errorMsg {
                
            } else {
                RPAuthRemoteAPI().socketInfo(with: ["username":""], userInfoAPI) { (userInfo, userInfoErrorMsg) in
                    if let userInfoErrorMsg = userInfoErrorMsg {
                        
                    } else {
                        
                    }
                }
            }
        }
```

**RxSwift**

使用RxSwift可以将多个请求合并处理，参考[RxSwift:等待多个并发任务完成后处理结果](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/why_rxswift.html)


* （1）、RxSwift的使用

同时，使用RxSwift，返回一个[Observable](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core.html),还可以避免嵌套回调的问题。

上面的代码用RxSwift来写，就直观了很多：

```
let _ = RPAuthRemoteAPI().signIn(with: ["username":"","password":""], signInAPI)
            .flatMap({ (returnJson) in
                return RPAuthRemoteAPI().userInfo(with: ["username":""], userInfoAPI)
            }).subscribe { (json) in
                print("用户信息-----------: \(json)")
            } onError: { (error) in

            } onCompleted: {

            } onDisposed: {

            }
```




来看看服务器给的接口文档

* （2）、请求服务器成功并正常返回数据

```
{
  "access_token" : "b6298027-a985-441c-a36c-d0a362520896",
  "user_id" : "1268805326995996673",
  "dept_id" : 1,
  "license" : "made by tsn",
  "scope" : "server",
  "token_type" : "bearer",
  "username" : "198031",
  "expires_in" : 19432,
  "refresh_token" : "692a1b6e-051f-424d-bd2e-3a9ccec8d4f2"
}
```

* （3）、 请求服务器成功，但返回数据异常，如参数错误，加密处理异常，登录超时等

```
{
  "returnCode" : "601",
  "returnMsg" : "登录失效",
}
```

* （4）、RxSwift对URLSession的扩展

`RxSwift`对系统提供的`URLSession`也做了扩展，可以让开发者直接使用：

```
URLSession.shared.rx.response(request: urlRequest).subscribe(onNext: { (response, data) in
            
}).disposed(by: disposeBag)
```

最终的代码为： 

```
/// 请求服务器相关
public protocol Request {
    var path: String {get}
    var method: HTTPMethod {get}
    var parameter: [String: AnyObject]? {get}
    var host: String {get}
}

extension Request {
    var parameter: [String: AnyObject] {
        return [:]
    }
}
/// 请求服务器失败时 错误码
public enum RequestError: Error {
   case unknownError
    case connectionError
    case timeoutError
    case authorizationError(JSON)
    case notFound
    case serverError}

/// 登录Request
struct SigninRequest: Request {
    typealias Response = SigninRequest
    var parameter: [String : AnyObject]?
    var path: String
    var method: HTTPMethod = .post
    var host: String {
        return __serverTestURL
    }
}

public protocol AuthRemoteProtocol {
/// 协议方式，成功返回JSON -----> RxSwift
    func requestData<T: Request>(_ r: T) -> Observable<JSON>
}

public struct RPAuthRemoteAPI: AuthRemoteProtocol {
    /// 协议方式，成功返回JSON -----> RxSwift
    public func post<T: Request>(_ r: T) -> Observable<JSON> {
        let path = URL(string: r.host.appending(r.path))!
        var urlRequest = URLRequest(url: path, cachePolicy: .useProtocolCachePolicy, timeoutInterval: 30)
        urlRequest.allHTTPHeaderFields  = ["Content-Type" : "application/x-www-form-urlencoded; application/json; charset=utf-8;"]
        urlRequest.httpMethod = r.method.rawValue
        if let parameter = r.parameter {
            // --> Data
            let parameterData = parameter.reduce("") { (result, param) -> String in
                return result + "&\(param.key)=\(param.value as! String)"
            }.data(using: .utf8)
            urlRequest.httpBody = parameterData
        }
     return Observable.create { (observer) -> Disposable in
            URLSession.shared.dataTask(with: urlRequest) { (data, response, error) in
                if let error = error {
                    print(error)
                    observer.onError(RequestError.connectionError)
                } else if let data = data ,let responseCode = response as? HTTPURLResponse {
                    do {
                        let json = try JSON(data: data)
                        switch responseCode.statusCode {
                        case 200:
                            print("json-------------\(json)")
                            observer.onNext(json)
                            observer.onCompleted()
                            break
                        case 201...299:
                            observer.onError(RequestError.authorizationError(json))
                            break
                        case 400...499:
                            observer.onError(RequestError.authorizationError(json))
                            break
                        case 500...599:
                            observer.onError(RequestError.serverError)
                            break
                        case 600...699:
                            observer.onError(RequestError.authorizationError(json))
                            break
                        default:
                            observer.onError(RequestError.unknownError)
                            break
                        }
                    }
                    catch let parseJSONError {
                        observer.onError(parseJSONError)
                        print("error on parsing request to JSON : \(parseJSONError)")
                    }
                }
            }.resume()
            return Disposables.create { }
     }
}
```

在ViewModel中调用的代码：

```
// 显示LoadingView
self.loading.onNext(true)
RPAuthRemoteAPI().post(SigninRequest(parameter: [:], path: path))
 .subscribe(onNext: { returnJson in
  // 成功
  self.loading.onNext(true)
 }, onError: { errorJson in
  // 失败
  self.loading.onNext(true)
}, onCompleted: {
  // 调用完成时
}).disposed(by: disposeBag)

```

--

友情链接：

[面向协议编程与 Cocoa 的邂逅](https://onevcat.com/2016/11/pop-cocoa-1/)

[Sample Music list app](https://github.com/mohammadZ74/MVVMRx_SampleProject)

[Github RxSwift](https://github.com/ReactiveX/RxSwift)

[RxSwift 中文网](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core.html)

[泊学网](https://boxueio.com/)